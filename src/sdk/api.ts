// @ts-nocheck
/**
 * SimpleLogin (unofficial)
 * The unofficial SimpleLogin API docs as OpenAPI 3.0.0 spec. This is based on the official markdown based docs, but written in OpenAPI to allow for easier integration with other tools and generation of client SDKs. Please do not contact the SimpleLogin team for support or issues with this API documentation.
 *
 * OpenAPI spec version: 4.22.0
 * Contact: contact@ketrwu.de
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
const isomorphicFetch = fetch;
import { Configuration } from "./configuration";

const BASE_PATH = "https://app.simplelogin.io/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     * 
     * @type {Date}
     * @memberof Alias
     */
    creationDate: Date;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    creationTimestamp: number;
    /**
     * 
     * @type {string}
     * @memberof Alias
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Alias
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Alias
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    id: number;
    /**
     * 
     * @type {AliasMailbox}
     * @memberof Alias
     */
    mailbox: AliasMailbox;
    /**
     * 
     * @type {Array<AliasMailbox>}
     * @memberof Alias
     */
    mailboxes: Array<AliasMailbox>;
    /**
     * 
     * @type {AliasLatestActivity}
     * @memberof Alias
     */
    latestActivity: AliasLatestActivity;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    nbBlock: number;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    nbForward: number;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    nbReply: number;
    /**
     * 
     * @type {string}
     * @memberof Alias
     */
    note: string;
    /**
     * 
     * @type {boolean}
     * @memberof Alias
     */
    pinned: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Alias
     */
    disablePgp: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Alias
     */
    supportPgp: boolean;
}
/**
 * 
 * @export
 * @interface AliasCustomNewPost
 */
export interface AliasCustomNewPost {
    /**
     * The first part of the alias that user can choose.
     * @type {string}
     * @memberof AliasCustomNewPost
     */
    aliasPrefix: string;
    /**
     * One of the suffixes returned in the options endpoint.
     * @type {string}
     * @memberof AliasCustomNewPost
     */
    signedSuffix: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AliasCustomNewPost
     */
    mailboxIds: Array<number>;
    /**
     * Note of this alias
     * @type {string}
     * @memberof AliasCustomNewPost
     */
    note?: string;
    /**
     * Name of this alias
     * @type {string}
     * @memberof AliasCustomNewPost
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface AliasLatestActivity
 */
export interface AliasLatestActivity {
    /**
     * 
     * @type {string}
     * @memberof AliasLatestActivity
     */
    action: string;
    /**
     * 
     * @type {AliasLatestActivityContact}
     * @memberof AliasLatestActivity
     */
    contact: AliasLatestActivityContact;
    /**
     * 
     * @type {number}
     * @memberof AliasLatestActivity
     */
    timestamp: number;
}
/**
 * 
 * @export
 * @interface AliasLatestActivityContact
 */
export interface AliasLatestActivityContact {
    /**
     * 
     * @type {string}
     * @memberof AliasLatestActivityContact
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof AliasLatestActivityContact
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AliasLatestActivityContact
     */
    reverseAlias: string;
}
/**
 * 
 * @export
 * @interface AliasMailbox
 */
export interface AliasMailbox {
    /**
     * 
     * @type {string}
     * @memberof AliasMailbox
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof AliasMailbox
     */
    id: number;
}
/**
 * 
 * @export
 * @interface AliasOptions
 */
export interface AliasOptions {
    /**
     * Whether the user can create an alias or not
     * @type {boolean}
     * @memberof AliasOptions
     */
    canCreate: boolean;
    /**
     * 
     * @type {string}
     * @memberof AliasOptions
     */
    prefixSuggestion: string;
    /**
     * 
     * @type {Array<AliasOptionsSuffixes>}
     * @memberof AliasOptions
     */
    suffixes: Array<AliasOptionsSuffixes>;
    /**
     * 
     * @type {Array<AliasOptionsRecommendation>}
     * @memberof AliasOptions
     */
    recommendation?: Array<AliasOptionsRecommendation>;
}
/**
 * 
 * @export
 * @interface AliasOptionsRecommendation
 */
export interface AliasOptionsRecommendation {
    /**
     * 
     * @type {string}
     * @memberof AliasOptionsRecommendation
     */
    alias: string;
    /**
     * 
     * @type {string}
     * @memberof AliasOptionsRecommendation
     */
    hostname: string;
}
/**
 * 
 * @export
 * @interface AliasOptionsSuffixes
 */
export interface AliasOptionsSuffixes {
    /**
     * 
     * @type {string}
     * @memberof AliasOptionsSuffixes
     */
    suffix: string;
    /**
     * 
     * @type {string}
     * @memberof AliasOptionsSuffixes
     */
    signedSuffix: string;
    /**
     * 
     * @type {boolean}
     * @memberof AliasOptionsSuffixes
     */
    isCustom: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AliasOptionsSuffixes
     */
    isPremium: boolean;
}
/**
 * 
 * @export
 * @interface AliasRandomNewPost
 */
export interface AliasRandomNewPost {
    /**
     * Note of this alias
     * @type {string}
     * @memberof AliasRandomNewPost
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface AuthActivatePost
 */
export interface AuthActivatePost {
    /**
     * Email address used to register account
     * @type {string}
     * @memberof AuthActivatePost
     */
    email: string;
    /**
     * Activation code sent to email
     * @type {string}
     * @memberof AuthActivatePost
     */
    code: string;
}
/**
 * 
 * @export
 * @interface AuthForgotPasswordPost
 */
export interface AuthForgotPasswordPost {
    /**
     * Email address used to register account
     * @type {string}
     * @memberof AuthForgotPasswordPost
     */
    email: string;
}
/**
 * 
 * @export
 * @interface AuthLogin
 */
export interface AuthLogin {
    /**
     * User's name, could be an empty string.
     * @type {string}
     * @memberof AuthLogin
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogin
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthLogin
     */
    mfaEnabled: boolean;
    /**
     * Only useful when user enables MFA. In this case, user needs to enter their OTP token in order to login.
     * @type {string}
     * @memberof AuthLogin
     */
    mfaKey: string;
    /**
     * If MFA is not enabled, the api key is returned right away.
     * @type {string}
     * @memberof AuthLogin
     */
    apiKey: string;
}
/**
 * 
 * @export
 * @interface AuthLoginPost
 */
export interface AuthLoginPost {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost
     */
    device: string;
}
/**
 * 
 * @export
 * @interface AuthMfa
 */
export interface AuthMfa {
    /**
     * User's name, could be an empty string
     * @type {string}
     * @memberof AuthMfa
     */
    name: string;
    /**
     * If MFA is not enabled, the api key is returned right away.
     * @type {string}
     * @memberof AuthMfa
     */
    apiKey: string;
    /**
     * User email
     * @type {string}
     * @memberof AuthMfa
     */
    email: string;
}
/**
 * 
 * @export
 * @interface AuthMfaPost
 */
export interface AuthMfaPost {
    /**
     * OTP token that user enters
     * @type {string}
     * @memberof AuthMfaPost
     */
    mfaToken: string;
    /**
     * MFA key obtained in previous auth request
     * @type {string}
     * @memberof AuthMfaPost
     */
    mfaKey: string;
    /**
     * The device name, used to create an ApiKey associated with this device
     * @type {string}
     * @memberof AuthMfaPost
     */
    device: string;
}
/**
 * 
 * @export
 * @interface AuthReactivatePost
 */
export interface AuthReactivatePost {
    /**
     * Email address used to register account
     * @type {string}
     * @memberof AuthReactivatePost
     */
    email: string;
}
/**
 * 
 * @export
 * @interface AuthRegisterPost
 */
export interface AuthRegisterPost {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost
     */
    password: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface Success
 */
export interface Success {
    /**
     * 
     * @type {boolean}
     * @memberof Success
     */
    ok: boolean;
}
/**
 * 
 * @export
 * @interface SudoPatch
 */
export interface SudoPatch {
    /**
     * 
     * @type {string}
     * @memberof SudoPatch
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface UserApiKey
 */
export interface UserApiKey {
    /**
     * 
     * @type {string}
     * @memberof UserApiKey
     */
    apiKey: string;
}
/**
 * 
 * @export
 * @interface UserApiKeyPost
 */
export interface UserApiKeyPost {
    /**
     * Device name
     * @type {string}
     * @memberof UserApiKeyPost
     */
    device: string;
}
/**
 * 
 * @export
 * @interface UserCookieToken
 */
export interface UserCookieToken {
    /**
     * 
     * @type {string}
     * @memberof UserCookieToken
     */
    token: string;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * User's full name
     * @type {string}
     * @memberof UserInfo
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    email: string;
    /**
     * Whether the user is a premium user or not
     * @type {boolean}
     * @memberof UserInfo
     */
    isPremium: boolean;
    /**
     * Whether the user is in trial period or not
     * @type {boolean}
     * @memberof UserInfo
     */
    inTrial: boolean;
    /**
     * URL of the user's profile picture
     * @type {string}
     * @memberof UserInfo
     */
    profilePicture: string;
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    maxAliasFreePlan: number;
}
/**
 * 
 * @export
 * @interface UserInfoPatch
 */
export interface UserInfoPatch {
    /**
     * Image of the new profile picture encoded in base64. Set to null to remove current profile picture.
     * @type {string}
     * @memberof UserInfoPatch
     */
    profilePicture?: string;
    /**
     * New name of the user
     * @type {string}
     * @memberof UserInfoPatch
     */
    name?: string;
}
/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a new account with the activation code that was sent to the user's email.
         * @summary Activate
         * @param {AuthActivatePost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(body: AuthActivatePost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling activate.');
            }
            const localVarPath = `/auth/activate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthActivatePost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a one time use cookie to exchange it for a valid cookie in the web app
         * @summary Cookie token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cookieToken(options: any = {}): FetchArgs {
            const localVarPath = `/user/cookie_token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @summary API key
         * @param {UserApiKeyPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: UserApiKeyPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createApiKey.');
            }
            const localVarPath = `/user/api_key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserApiKeyPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user (requires sudo mode)
         * @summary User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable sudo mode
         * @summary Sudo mode
         * @param {SudoPatch} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSudoMode(body: SudoPatch, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling enableSudoMode.');
            }
            const localVarPath = `/sudo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SudoPatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a link to reset the password for a registered account.
         * @summary Forgot password
         * @param {AuthForgotPasswordPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(body: AuthForgotPasswordPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling forgotPassword.');
            }
            const localVarPath = `/auth/forgot_password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthForgotPasswordPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login using email and password to get an access token.
         * @summary Login
         * @param {AuthLoginPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: AuthLoginPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthLoginPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log out user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options: any = {}): FetchArgs {
            const localVarPath = `/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate using MFA
         * @summary MFA authentication
         * @param {AuthMfaPost} body The api_key is used in all subsequent requests. It&#x27;s empty if MFA is enabled. If user hasn&#x27;t enabled MFA, mfa_key is empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfa(body: AuthMfaPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling mfa.');
            }
            const localVarPath = `/auth/mfa`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthMfaPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a new activation code for an account that was already registered, but not activated yet.
         * @summary Reactivate
         * @param {AuthReactivatePost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivate(body: AuthReactivatePost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reactivate.');
            }
            const localVarPath = `/auth/reactivate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthReactivatePost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new account
         * @summary Register
         * @param {AuthRegisterPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: AuthRegisterPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling register.');
            }
            const localVarPath = `/auth/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthRegisterPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user info
         * @summary User info
         * @param {UserInfoPatch} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfo(body: UserInfoPatch, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserInfo.');
            }
            const localVarPath = `/user_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserInfoPatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user info
         * @summary User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInfo(options: any = {}): FetchArgs {
            const localVarPath = `/user_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Activate a new account with the activation code that was sent to the user's email.
         * @summary Activate
         * @param {AuthActivatePost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(body: AuthActivatePost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).activate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a one time use cookie to exchange it for a valid cookie in the web app
         * @summary Cookie token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cookieToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCookieToken> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).cookieToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new API key
         * @summary API key
         * @param {UserApiKeyPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: UserApiKeyPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserApiKey> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).createApiKey(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete user (requires sudo mode)
         * @summary User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteUser(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable sudo mode
         * @summary Sudo mode
         * @param {SudoPatch} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSudoMode(body: SudoPatch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).enableSudoMode(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request a link to reset the password for a registered account.
         * @summary Forgot password
         * @param {AuthForgotPasswordPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(body: AuthForgotPasswordPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).forgotPassword(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Login using email and password to get an access token.
         * @summary Login
         * @param {AuthLoginPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: AuthLoginPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthLogin> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Log out user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).logout(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticate using MFA
         * @summary MFA authentication
         * @param {AuthMfaPost} body The api_key is used in all subsequent requests. It&#x27;s empty if MFA is enabled. If user hasn&#x27;t enabled MFA, mfa_key is empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfa(body: AuthMfaPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthMfa> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).mfa(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request a new activation code for an account that was already registered, but not activated yet.
         * @summary Reactivate
         * @param {AuthReactivatePost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivate(body: AuthReactivatePost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).reactivate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Register a new account
         * @summary Register
         * @param {AuthRegisterPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: AuthRegisterPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).register(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update user info
         * @summary User info
         * @param {UserInfoPatch} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfo(body: UserInfoPatch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).updateUserInfo(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get user info
         * @summary User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).userInfo(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Activate a new account with the activation code that was sent to the user's email.
         * @summary Activate
         * @param {AuthActivatePost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(body: AuthActivatePost, options?: any) {
            return AccountApiFp(configuration).activate(body, options)(fetch, basePath);
        },
        /**
         * Get a one time use cookie to exchange it for a valid cookie in the web app
         * @summary Cookie token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cookieToken(options?: any) {
            return AccountApiFp(configuration).cookieToken(options)(fetch, basePath);
        },
        /**
         * Create a new API key
         * @summary API key
         * @param {UserApiKeyPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: UserApiKeyPost, options?: any) {
            return AccountApiFp(configuration).createApiKey(body, options)(fetch, basePath);
        },
        /**
         * Delete user (requires sudo mode)
         * @summary User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any) {
            return AccountApiFp(configuration).deleteUser(options)(fetch, basePath);
        },
        /**
         * Enable sudo mode
         * @summary Sudo mode
         * @param {SudoPatch} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSudoMode(body: SudoPatch, options?: any) {
            return AccountApiFp(configuration).enableSudoMode(body, options)(fetch, basePath);
        },
        /**
         * Request a link to reset the password for a registered account.
         * @summary Forgot password
         * @param {AuthForgotPasswordPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(body: AuthForgotPasswordPost, options?: any) {
            return AccountApiFp(configuration).forgotPassword(body, options)(fetch, basePath);
        },
        /**
         * Login using email and password to get an access token.
         * @summary Login
         * @param {AuthLoginPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: AuthLoginPost, options?: any) {
            return AccountApiFp(configuration).login(body, options)(fetch, basePath);
        },
        /**
         * Log out user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any) {
            return AccountApiFp(configuration).logout(options)(fetch, basePath);
        },
        /**
         * Authenticate using MFA
         * @summary MFA authentication
         * @param {AuthMfaPost} body The api_key is used in all subsequent requests. It&#x27;s empty if MFA is enabled. If user hasn&#x27;t enabled MFA, mfa_key is empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfa(body: AuthMfaPost, options?: any) {
            return AccountApiFp(configuration).mfa(body, options)(fetch, basePath);
        },
        /**
         * Request a new activation code for an account that was already registered, but not activated yet.
         * @summary Reactivate
         * @param {AuthReactivatePost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivate(body: AuthReactivatePost, options?: any) {
            return AccountApiFp(configuration).reactivate(body, options)(fetch, basePath);
        },
        /**
         * Register a new account
         * @summary Register
         * @param {AuthRegisterPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: AuthRegisterPost, options?: any) {
            return AccountApiFp(configuration).register(body, options)(fetch, basePath);
        },
        /**
         * Update user info
         * @summary User info
         * @param {UserInfoPatch} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfo(body: UserInfoPatch, options?: any) {
            return AccountApiFp(configuration).updateUserInfo(body, options)(fetch, basePath);
        },
        /**
         * Get user info
         * @summary User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInfo(options?: any) {
            return AccountApiFp(configuration).userInfo(options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Activate a new account with the activation code that was sent to the user's email.
     * @summary Activate
     * @param {AuthActivatePost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public activate(body: AuthActivatePost, options?: any) {
        return AccountApiFp(this.configuration).activate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a one time use cookie to exchange it for a valid cookie in the web app
     * @summary Cookie token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public cookieToken(options?: any) {
        return AccountApiFp(this.configuration).cookieToken(options)(this.fetch, this.basePath);
    }

    /**
     * Create a new API key
     * @summary API key
     * @param {UserApiKeyPost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createApiKey(body: UserApiKeyPost, options?: any) {
        return AccountApiFp(this.configuration).createApiKey(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete user (requires sudo mode)
     * @summary User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteUser(options?: any) {
        return AccountApiFp(this.configuration).deleteUser(options)(this.fetch, this.basePath);
    }

    /**
     * Enable sudo mode
     * @summary Sudo mode
     * @param {SudoPatch} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public enableSudoMode(body: SudoPatch, options?: any) {
        return AccountApiFp(this.configuration).enableSudoMode(body, options)(this.fetch, this.basePath);
    }

    /**
     * Request a link to reset the password for a registered account.
     * @summary Forgot password
     * @param {AuthForgotPasswordPost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public forgotPassword(body: AuthForgotPasswordPost, options?: any) {
        return AccountApiFp(this.configuration).forgotPassword(body, options)(this.fetch, this.basePath);
    }

    /**
     * Login using email and password to get an access token.
     * @summary Login
     * @param {AuthLoginPost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public login(body: AuthLoginPost, options?: any) {
        return AccountApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

    /**
     * Log out user
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public logout(options?: any) {
        return AccountApiFp(this.configuration).logout(options)(this.fetch, this.basePath);
    }

    /**
     * Authenticate using MFA
     * @summary MFA authentication
     * @param {AuthMfaPost} body The api_key is used in all subsequent requests. It&#x27;s empty if MFA is enabled. If user hasn&#x27;t enabled MFA, mfa_key is empty.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public mfa(body: AuthMfaPost, options?: any) {
        return AccountApiFp(this.configuration).mfa(body, options)(this.fetch, this.basePath);
    }

    /**
     * Request a new activation code for an account that was already registered, but not activated yet.
     * @summary Reactivate
     * @param {AuthReactivatePost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public reactivate(body: AuthReactivatePost, options?: any) {
        return AccountApiFp(this.configuration).reactivate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Register a new account
     * @summary Register
     * @param {AuthRegisterPost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public register(body: AuthRegisterPost, options?: any) {
        return AccountApiFp(this.configuration).register(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update user info
     * @summary User info
     * @param {UserInfoPatch} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateUserInfo(body: UserInfoPatch, options?: any) {
        return AccountApiFp(this.configuration).updateUserInfo(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get user info
     * @summary User info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public userInfo(options?: any) {
        return AccountApiFp(this.configuration).userInfo(options)(this.fetch, this.basePath);
    }

}
/**
 * AliasApi - fetch parameter creator
 * @export
 */
export const AliasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user aliases
         * @summary Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliases(options: any = {}): FetchArgs {
            const localVarPath = `/v2/aliases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new custom alias
         * @summary Create custom
         * @param {AliasCustomNewPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustom(body: AliasCustomNewPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCustom.');
            }
            const localVarPath = `/v3/alias/custom/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AliasCustomNewPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new random alias
         * @summary Create random
         * @param {AliasRandomNewPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandom(body: AliasRandomNewPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRandom.');
            }
            const localVarPath = `/alias/random/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AliasRandomNewPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User alias info and suggestion. Used by the first extension screen when user opens the extension.
         * @summary Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        options(options: any = {}): FetchArgs {
            const localVarPath = `/v5/alias/options`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AliasApi - functional programming interface
 * @export
 */
export const AliasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get user aliases
         * @summary Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliases(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alias> {
            const localVarFetchArgs = AliasApiFetchParamCreator(configuration).aliases(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new custom alias
         * @summary Create custom
         * @param {AliasCustomNewPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustom(body: AliasCustomNewPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alias> {
            const localVarFetchArgs = AliasApiFetchParamCreator(configuration).createCustom(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new random alias
         * @summary Create random
         * @param {AliasRandomNewPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandom(body: AliasRandomNewPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alias> {
            const localVarFetchArgs = AliasApiFetchParamCreator(configuration).createRandom(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * User alias info and suggestion. Used by the first extension screen when user opens the extension.
         * @summary Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        options(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AliasOptions> {
            const localVarFetchArgs = AliasApiFetchParamCreator(configuration).options(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AliasApi - factory interface
 * @export
 */
export const AliasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get user aliases
         * @summary Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliases(options?: any) {
            return AliasApiFp(configuration).aliases(options)(fetch, basePath);
        },
        /**
         * Create a new custom alias
         * @summary Create custom
         * @param {AliasCustomNewPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustom(body: AliasCustomNewPost, options?: any) {
            return AliasApiFp(configuration).createCustom(body, options)(fetch, basePath);
        },
        /**
         * Create a new random alias
         * @summary Create random
         * @param {AliasRandomNewPost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandom(body: AliasRandomNewPost, options?: any) {
            return AliasApiFp(configuration).createRandom(body, options)(fetch, basePath);
        },
        /**
         * User alias info and suggestion. Used by the first extension screen when user opens the extension.
         * @summary Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        options(options?: any) {
            return AliasApiFp(configuration).options(options)(fetch, basePath);
        },
    };
};

/**
 * AliasApi - object-oriented interface
 * @export
 * @class AliasApi
 * @extends {BaseAPI}
 */
export class AliasApi extends BaseAPI {
    /**
     * Get user aliases
     * @summary Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasApi
     */
    public aliases(options?: any) {
        return AliasApiFp(this.configuration).aliases(options)(this.fetch, this.basePath);
    }

    /**
     * Create a new custom alias
     * @summary Create custom
     * @param {AliasCustomNewPost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasApi
     */
    public createCustom(body: AliasCustomNewPost, options?: any) {
        return AliasApiFp(this.configuration).createCustom(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new random alias
     * @summary Create random
     * @param {AliasRandomNewPost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasApi
     */
    public createRandom(body: AliasRandomNewPost, options?: any) {
        return AliasApiFp(this.configuration).createRandom(body, options)(this.fetch, this.basePath);
    }

    /**
     * User alias info and suggestion. Used by the first extension screen when user opens the extension.
     * @summary Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasApi
     */
    public options(options?: any) {
        return AliasApiFp(this.configuration).options(options)(this.fetch, this.basePath);
    }

}
